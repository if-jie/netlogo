---
title: 'Introducción al ML'
taxonomy:
    category: docs
visible: true
---

<img style="float:left;margin:0 10px 10px 0;" src="http://3.bp.blogspot.com/-u7Fkk8haI40/TuOkKrTbbWI/AAAAAAAADUU/Hsib8G7daYA/s1600/ml-robot.png"/> Grosso modo, el **Aprendizaje Automático** (AA, o **Machine Learning,** por su nombre en inglés) es la rama de la Inteligencia Artificial que tiene como objetivo desarrollar técnicas que permitan a las computadoras aprender. De forma más concreta, se trata de crear algortimos capaces de generalizar comportamientos y reconocer patrones a partir de una información suministrada en forma de ejemplos. Es, por lo tanto, un proceso de **inducción del conocimiento**, es decir, un método que permite obtener por generalización un enunciado general a partir de enunciados que describen casos particulares.

Cuando se han observado todos los casos particulares la inducción se considera **completa**, por lo que la generalización a la que da lugar se considera **válida**. No obastante, en la mayoría de los casos es imposible obtener una inducción completa, por lo que el enunciado a que da lugar queda sometido a un cierto grado de incertidumbre, y en consecuencia no se puede considerar como un esquema de inferencia formalmente válido ni se puede justificar empíricamente. En muchas ocasiones el campo de actuación del aprendizaje automático se solapa con el de **Data Mining**, ya que las dos disciplinas están enfocadas en el análisis de datos, sin embargo el aprendizaje automático se centra más en el estudio de la complejidad computacional de los problemas con la intención de hacerlos factibles desde el punto de vista práctico, no únicamente teórico.

A un nivel muy básico, podríamos decir que una de las tareas del AA es intentar extraer conocimiento sobre algunas propiedades no observadas de un objeto basándose en las propiedades que sí han sido observadas de ese mismo objeto (o incluso de propiedades observadas en otros objetos similares)... o, en palabras más llanas, **predecir** comportamiento futuro a partir de lo que ha ocurrido en el pasado. Un ejemplo de mucha actualidad sería, por ejemplo, el de predecir si un determinado producto le va a gustar a un cliente basándonos en las valoraciones que ese mismo cliente ha hecho de otros productos que sí ha probado.

En cualquier caso, como el tema del que estamos hablando está relacionado con el aprendizaje, lo primero que hemos de preguntarnos es **¿Qué entendemos por aprender?** y, ya que queremos dar metodologías generales para producir un aprendizaje de forma automática, una vez que fijemos este concepto habremos de dar métodos para medir el grado de éxito/fracaso de un aprendizaje. En cualquier caso, ya que estamos trasladando un concepto intuitivo y que usamos normalmente en la vida diaria a un contexto computacional, ha de tenerse en cuenta que todas las definiciones que demos de aprendizaje desde un punto de vista computacional, así como las diversas formas de medirlo, estarán íntimamente relacionadas con contextos muy concretos y posiblemente lejos de lo que intuitivamente, y de forma general, entendemos por aprendizaje.

Una definición relativamente general de **aprendizaje** dentro del contexto humano podría ser la siguiente: _proceso a través del cual se adquieren o modifican habilidades, destrezas, conocimientos, conductas o valores como resultado del estudio, la experiencia, la instrucción, el razonamiento y la observación_. De esta definición es importante hacer notar que el aprendizaje debe producirse a partir de la experiencia con el entorno, no se considera aprendizaje toda aquella habilidad o conocimiento que sean innatos en el individuo o que se adquieran como resultado del crecimiento natural de éste. Siguiendo un esquema similar, en el AA vamos a considerar aprendizaje a aquello que la máquina pueda **aprender a partir de la experiencia**, no a partir del reconocimiento de patrones programados a priori. Por tanto, una tarea central de cómo aplicar esta definición al contexto de la computación va a consistir en alimentar la experiencia de la máquina por medio de objetos con los que entrenarse (**ejemplos**) para, posteriormente, aplicar los patrones que haya reconocido sobre otros objetos distintos (en un sistema de recomendación de productos, un ejemplo sería un par particular cliente/producto, junto con la información acerca de la valoración que aquel haya hecho de éste)..

<img src="http://blog.adnanmasood.com/wp-content/uploads/2012/04/ml-wordle-1024x546.jpg"/>

Hay un gran número de problemas que caen dentro de lo que llamamos **aprendizaje inductivo**. La principal diferencia entre ellos estriba en el tipo de objetos que intentan predecir. Algunas clases habituales son:

*   **Regresión**: Intentan predecir un valor real. Por ejemplo, predecir el valor de la bolsa mañana a partir del comportamiento de la bolsa que está almacenado (pasado). O predecir la nota de un alumno en el examen final basándose en las notas obtenidas en las diversas tareas realizadas durante el curso.
*   **Clasificación** (binaria o multiclase): Intentan predecir la clasificación de objetos sobre un conjunto de clases prefijadas. Por ejemplo, clasificar si una determinada noticia es de deportes, entretenimiento, política, etc. Si solo se permiten 2 posibles clases, entonces se llama **clasificación binaria**; si se permiten más de 2 clases, estamos hablando de **clasificación multiclase**.
*   **Ranking**: Intentar predecir el orden óptimo de un conjunto de objetos según un orden de relevancia predefinido. Por ejemplo, el orden en que un buscador devuelve recursos de internet como respuesta a una búsqueda de un usuario.

<img src="http://mlpy.sourceforge.net/images/screenshots.jpg"/>

Normalmente, cuando se aborda un nuevo problema de AA lo primero que se hace es emarcarlo dentro de alguna de las clases anteriores, ya que dependiendo de cómo se clasifique será la forma en que podemos medir el error cometido entre la predicción y la realidad. En consecuencia, el problema de medir cómo de acertado es el aprendizaje obtenido deberá ser tratado para cada caso particular de metodología aplicada, aunque en general podemos adelantar que necesitaremos "embeber" la representación del problema en un espacio en el que tengamos definida una medida.

Por otra parte, y dependiendo del tipo de salida que se produzca y de cómo se aborde el tratamiento de los ejemplos, los diferentes algoritmos de AA se pueden agrupar en:

*   **Aprendizaje supervisado**: se genera una función que establece una correspondencia entre las entradas y las salidas deseadas del sistema, donde la base de conocimientos del sistema está formada por **ejemplos etiquetados** a priori (es decir, ejemplos de los que sabemos su clasificación correcta). Un ejemplo de este tipo de algoritmo es el problema de clasificación al que hemos hecho mención anteriormente.
*   **Aprendizaje no supervisado**: donde el proceso de modelado se lleva a cabo sobre un conjunto de ejemplos formados únicamente por entradas al sistema, sin conocer su clasificación correcta. Por lo que se busca que el sistema sea capaz de reconocer patrones para poder etiquetar las nuevas entradas.
*   **Aprendizaje semisupervisado**: es una combinación de los dos algoritmos anteriores, teniendo en cuanta ejemplos clasificados y no clasificados.
*   **Aprendizaje por refuerzo**: en este caso el algoritmo aprende observando el mundo que le rodea y con un continuo flujo de información en las dos direcciones (del mundo a la máquina, y de la máquina al mundo) realizando un proceso de ensayo-error, y reforzando aquellas acciones que reciben una respuesta positiva en el mundo.
*   **Transducción**: es similar al aprendizaje supervisado, pero su objetivo no es construir de forma explícita una función, sino únicamente tratar de predecir las categorías en las que caen los siquientes ejemplos basándose en los ejemplos de entrada, sus respectivas categorías y los ejemplos nuevos al sistema. Es decir, estaría más cerca del concepto de aprendizaje supervisado dinámico.
*   **Aprendizaje multi-tarea**: engloba todos aquellos métodos de aprendizaje que usan conocimiento previamente aprendido por el sistema de cara a enfrentarse a problemas parecidos a los ya vistos.

En este otro post puedes encontrar el primero de una serie de entradas que tienen como objetivo presentar los [Fundamentos Matemáticos del Aprendizaje Automático](http://www.cs.us.es/~fsancho/?e=169) de una forma amigable (espero).